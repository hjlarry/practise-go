package main

import "reflect"

// type X int

// func (x X) A()  {}
// func (x *X) B() {}

// func main() {
// 	var o X = 100
// 	// 为什么o只拥有一个方法A，却能调用方法B？这是编译器的一种内部机制帮我们把o.B() 转换为(*X).B(&o)
// 	// 问题是这种方式不是100%有效的，o可能是无法寻址的
// 	// 所以o和&o的方法集是不同的
// 	t := reflect.TypeOf(o)
// 	// t := reflect.TypeOf(&o)

// 	for i := 0; i < t.NumMethod(); i++ {
// 		println(t.Method(i).Name)
// 	}
// 	// 验证无法寻址的情况
// 	y := map[string]X{}
// 	y["a"] = o
// 	y["a"].A()
// 	y["a"].B()
// 	// ./methodset.go:25:8: cannot call pointer method on y["a"]
// 	// ./methodset.go:25:8: cannot take the address of y["a"]
// }

// --------------------------------------------------------------------------
// go tool objdump -s "main\." methodset | grep "TEXT main\."
// TEXT main.X.A(SB) /root/.mac/gocode/methodset.go
// TEXT main.(*X).B(SB) /root/.mac/gocode/methodset.go
// TEXT main.main(SB) /root/.mac/gocode/methodset.go
// TEXT main.(*X).A(SB) <autogenerated>
// TEXT main.(*S).A(SB) <autogenerated>
// TEXT main.(*S).B(SB) <autogenerated>
// TEXT main.S.A(SB) <autogenerated>
// 我们发现编译器帮我们自动生成了四个方法
// 在我们直接通过o.A()这样调用时，编译器会帮我们转化为call main.X.A(o)这样
// 但当我们通过反射查看时，编译器会生成新的方法及签名，我们通过反汇编查看这些生成的方法指令，最终仍然是调用原方法
// 这是因为反射是通过接口查看的，接口有严格的协议要求，编译器才会自动生成相应的方法
type X int

//go:noinline
func (x X) A() {}

//go:noinline
func (x *X) B() {}

type S struct {
	X
}

func main() {
	var o S
	t := reflect.TypeOf(o)
	for i := 0; i < t.NumMethod(); i++ {
		println(t.Method(i).Name)
	}
}
